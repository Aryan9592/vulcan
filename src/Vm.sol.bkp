// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.0;

import "forge-std/Vm.sol";

struct _T {
    uint8 t;
}

struct Log {
    bytes32[] topics;
    bytes data;
    address emitter;
}

struct Rpc {
    string name;
    string url;
}

// TODO: most variable names and comments are the ones provided by the forge-std library, figure out if we should change/improve/remove some of them
// @dev Main entry point to vm functionality
library VmLib {
    uint256 internal constant VM_SLOT = uint256(keccak256("sest.vm.slot")); 
    Vm internal constant DEFAULT_VM = Vm(address(bytes20(uint160(uint256(keccak256('hevm cheat code'))))));

    function vm() internal view returns(Vm _vm) {
        uint256 vmSlot = VM_SLOT;
        assembly {
            _vm := sload(vmSlot)
        }
    }

    function vm(_T memory) internal view returns(Vm) {
        return vm();
    }

    function setVm(_T memory self, Vm _vm) internal returns(_T memory) {
        uint256 vmSlot = VM_SLOT;
        assembly {
            sstore(vmSlot, _vm)
        }
        return self;
    }

    // Stops collecting onchain transactions
    function stopBroadcast(_T memory) internal;
    // Reads the entire content of file to string, (path) => (data)
    function readFile(_T memory, string calldata) internal view returns (string memory);
    // Reads the entire content of file as binary. Path is relative to the project root. (path) => (data)
    function readFileBinary(_T memory, string calldata) internal view returns (bytes memory);
    // Get the path of the current project root
    function projectRoot() internal view returns (string memory);
    // Reads next line of file to string, (path) => (line)
    function readLine(string calldata) internal view returns (string memory);
    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
    // (path, data) => ()
    function writeFile(string calldata, string calldata) internal;
    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
    // Path is relative to the project root. (path, data) => ()
    function writeFileBinary(string calldata, bytes calldata) internal;
    // Writes line to file, creating a file if it does not exist.
    // (path, data) => ()
    function writeLine(string calldata, string calldata) internal;
    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
    // (path) => ()
    function closeFile(string calldata) internal;
    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:
    // - Path points to a directory.
    // - The file doesn't exist.
    // - The user lacks permissions to remove the file.
    // (path) => ()
    function removeFile(string calldata) internal;
    // Convert values to a string, (value) => (stringified value)
    function toString(address) internal pure returns (string memory);
    function toString(bytes calldata) internal pure returns (string memory);
    function toString(bytes32) internal pure returns (string memory);
    function toString(bool) internal pure returns (string memory);
    function toString(uint256) internal pure returns (string memory);
    function toString(int256) internal pure returns (string memory);
    // Convert values from a string, (string) => (parsed value)
    function parseBytes(string calldata) internal pure returns (bytes memory);
    function parseAddress(string calldata) internal pure returns (address);
    function parseUint(string calldata) internal pure returns (uint256);
    function parseInt(string calldata) internal pure returns (int256);
    function parseBytes32(string calldata) internal pure returns (bytes32);
    function parseBool(string calldata) internal pure returns (bool);
    // Record all the transaction logs
    function recordLogs() internal;
    // Gets all the recorded logs, () => (logs)
    function getRecordedLogs() internal returns (Log[] memory);
    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}
    function deriveKey(string calldata, uint32) internal pure returns (uint256);
    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}
    function deriveKey(string calldata, string calldata, uint32) internal pure returns (uint256);
    // Adds a private key to the local forge wallet and returns the address
    function rememberKey(uint256) internal returns (address);
    //
    // parseJson
    //
    // ----
    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects
    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in
    // ALPHABETICAL ordser. That means that in order to succesfully decode the tuple, we need to define a tuple that
    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded
    // as tuples, with the attributes in the order in which they are defined.
    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}
    // a: uint256
    // b: address
    // To decode that json, we need to define a struct or a tuple as follows:
    // struct json = { uint256 a; address b; }
    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to
    // decode the tuple in that order, and thus fail.
    // ----
    // Given a string of JSON, return it as ABI-encoded, (stringified json, key) => (ABI-encoded data)
    function parseJson(string calldata, string calldata) internal pure returns (bytes memory);
    function parseJson(string calldata) internal pure returns (bytes memory);
    //
    // writeJson
    //
    // ----
    // Let's assume we want to write the following JSON to a file:
    //
    // { "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
    //
    // ```
    //  string memory json1 = "some key";
    //  vm.serializeBool(json1, "boolean", true);
    //  vm.serializeBool(json1, "number", uint256(342));
    //  json2 = "some other key";
    //  string memory output = vm.serializeString(json2, "title", "finally json serialization");
    //  string memory finalJson = vm.serialize(json1, "object", output);
    //  vm.writeJson(finalJson, "./output/example.json");
    // ```
    //  The critical insight is that every invocation of serialization will return the stringified version of the JSON
    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version
    // to serialize them as values to another JSON object.
    //
    //  json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)
    //  will find the object in-memory that is keyed by "some key".   // writeJson
    // ----
    // Serialize a key and value to a JSON object stored in-memory that can be latery written to a file
    // It returns the stringified version of the specific JSON file up to that moment.
    // (object_key, value_key, value) => (stringified JSON)
    function serializeBool(string calldata, string calldata, bool) internal returns (string memory);
    function serializeUint(string calldata, string calldata, uint256) internal returns (string memory);
    function serializeInt(string calldata, string calldata, int256) internal returns (string memory);
    function serializeAddress(string calldata, string calldata, address) internal returns (string memory);
    function serializeBytes32(string calldata, string calldata, bytes32) internal returns (string memory);
    function serializeString(string calldata, string calldata, string calldata) internal returns (string memory);
    function serializeBytes(string calldata, string calldata, bytes calldata) internal returns (string memory);

    function serializeBool(string calldata, string calldata, bool[] calldata) internal returns (string memory);
    function serializeUint(string calldata, string calldata, uint256[] calldata) internal returns (string memory);
    function serializeInt(string calldata, string calldata, int256[] calldata) internal returns (string memory);
    function serializeAddress(string calldata, string calldata, address[] calldata) internal returns (string memory);
    function serializeBytes32(string calldata, string calldata, bytes32[] calldata) internal returns (string memory);
    function serializeString(string calldata, string calldata, string[] calldata) internal returns (string memory);
    function serializeBytes(string calldata, string calldata, bytes[] calldata) internal returns (string memory);
    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.
    // (stringified_json, path)
    function writeJson(string calldata, string calldata) internal;
    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>
    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing
    // (stringified_json, path, value_key)
    function writeJson(string calldata, string calldata, string calldata) internal;
    // Returns the RPC url for the given alias
    function rpcUrl(string calldata) internal view returns (string memory);
    // Returns all rpc urls and their aliases `[alias, url][]`
    function rpcUrls() internal view returns (string[2][] memory);
    // Returns all rpc urls and their aliases as structs.
    function rpcUrlStructs() internal view returns (Rpc[] memory);
    // If the condition is false, discard this run's fuzz inputs and generate new ones.
    function assume(bool) internal pure;

}

using VmLib for _T global;